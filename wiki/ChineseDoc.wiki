#summary One-sentence summary of this page.

= Introduction =

EMake 是一个 Make工具，用来从源文件输出可执行文件。EMake直接从源文件的注释中提取EMake宏指令，来确定这个工程有哪些源文件，他们该如何编译（编译参数，或者头文件路径），并且输出成什么格式（可执行，动态库，静态库，Windows下的窗口模式可执行）。

GNU Make是一个强大的工具，但大部分时候我不会去写一个非常大的需要用Makefile的工程，我经常写一些中小项目，代码在2万行以内，甚至更少（比如几百行）。为每个小工程都编写一个新的Makefile（或者修改一下旧的）是一件非常累的事情（当然你也可以写个足够强大的Makefile来应付我说的情况，但并非大多数人的用法）。

因此我所需要的是像Visual Studio工程管理一样简单直观的编译工具，让我简单的：增加源文件，然后编译他们。这这么简单，所有源代码依赖的头文件都会自动被分析出来，一旦更改，就需要编译他们，否则就跳过。所有繁琐的编译参数都有默认值，在大多数情况下你可以不去管他们，而当你需要时，你可以去定制。

EMake就是一个让你从繁重的Makefile维护中解放出来的工具，它并不是一个GNU Make的 Replacement，只是一个合理的补充，让你用代码中的注释宏来精简的描述工程信息，当你源代码改变的时候，你也可以随手改变工程信息，而且你可以用它指定各种详细的编译细节，真正做到简单，并且真切有力。




= Details =

= Features =
EMake gets its knowledge of how to build your program from the comment macro of the main source file. The comment macro describes how to compile the whole project. You can use "//!" as the Emake macro in your source file, such like you have this line in main.c:
{{{
//! exe: file1.c, file2.c
}}}

when you call *"emake.py main.c"*, Emake will know this project has three files: file1.c, file2.c and main.c itselfs. and the output mode is "exe" (it can be *"exe/dll/clib/win"*). Then emake will parse all the source files in the project. 

In the second step, Emake will indicate what header files are used in each source file, and check if the source need to be compiled. (the timestamps of the source file and its header files is newer than the its obj file).

At last, Emake will call gcc to compile the source files in the project, and then link them to generate the executable file (or dynamic/static library).

Emake gets its knowledge directly from the source file comments, which avoid writing another Makefile. You can describe project source files, compiler flags, include/library directories, linking mode, ... etc directly in your C files with a few comment macro.

Providing a completely *new way to build projects*, emake is very suitable for small or medium projects, You can describe your project much simply than traditional GNU make, then detect dependences, at last build it. It is easy to make MAKE easy.

=Installation=

EMake is written with python in a single .py file. You can download the tarball and extract emake.py into current folder. Note, emake only supports gcc right now, so if you are under windows, you must download mingw to work with.

===Install EMake in Unix===
use *"./emake.py -install"* to install. The installation will copy itself into /usr/local/bin. It will search gcc in /usr/bin or /usr/local/bin.

===Install EMake in Windows with mingw===
copy emake.py into the root directory of mingw, in order to find gcc.exe in ".\bin\" directory. then you can execute as "c:\mingw\emake.py"



=Examples=

===Build with multi-source-file project===

*testmain.c:*
{{{
#include <stdio.h>
#include "testsrc1.h"

//! mode: exe
//! flag: -O3
//! link: m
//! out: testmain
//! src: testmain.c, testsrc1.c
int main(void)
{
	foo();
	return 0;
}
}}}

 * The comment macro *"//!"* tells emake this is an EMake Macro, 
 * *mode* tells emake the output format is an executable file (It can be 'exe', 'dll', 'lib').
 * *out* tells emake the output file's name
 * *src* tells emake there are two source files(testmain.c and testsrc1.c)
 * *flag* tells emake to send "-O3" to gcc parameters in compiling
 * *link* tells emake to send "-lm" to gcc parameters in linking


*testsrc1.h:*
{{{
#ifndef __TESTSRC1_H__
#define __TESTSRC1_H__

void foo(void);

#endif
}}}

*testsrc1.c:*
{{{
#include <stdio.h>
#include "testsrc1.h"

void foo(void)
{
	printf("This is foo\n");
}
}}}

Then you can use emake to build this project:
{{{
% python emake.py testmain.c
compiling ...
testmain.c
testsrc1.c
linking ...
}}}

Then you can run your executable file:
{{{
% ./testmain
This is foo
}}}

Actually EMake has done these things below for you:
{{{
gcc -O3 -c testmain.c -o testmain.o
gcc -O3 -c testsrc1.c -o testsrc1.o
gcc testmain.o testsrc1.o -o testmain -lm
}}}


===Build with multi-source files===

There is a main.c which contains the following comment lines as emake macro:

{{{
//! exe: source1.c, source2.c
}}}

Emake will generate executable file with source1.c and source2.c and main.c. It will do there jobs below for you:

{{{
gcc -c source1.c -o source1.o
gcc -c source2.c -o source2.o
gcc -c main.c -o main.o
gcc main.o source1.o source2.o -o main
}}}


===Build with special GCC parameters===
{{{
//! flags: -O3, -g
//! link: stdc++, pthread
//! exe: source1.c, source2.c
}}}

EMake will do these jobs below for you:

{{{
gcc -O3 -g -c source1.c -o source1.o
gcc -O3 -g -c source2.c -o source2.o
gcc -O3 -g -c main.c -o main.o
gcc main.o source1.o source2.o -o main -lstdc++ -lpthread
}}}

===Build a dynamic link file===
{{{
//! dll: src1.c, src2.c
}}}

===Build a static link file===
{{{
//! clib: src1.c, src2.c
}}}

===Add Including/Librarys Directories===
{{{
//! inc: ../ffmpeg/include
//! inc: ../ogg/include
//! lib: ../ffmpeg/lib
//! lib: ../ogg/lib
//! exe: src1, src2
}}}

EMake will do these jobs below for you:
{{{
gcc -I../ffmpeg/include -I../ogg/include -c src1.c -o src1.o
gcc -I../ffmpeg/include -I../ogg/include -c src2.c -o src2.o
gcc -I../ffmpeg/include -I../ogg/include -c main.c -o main.o
gcc -L../ffmpeg/lib -L../ogg/lib src1.o src2.o main.o -o main
}}}

